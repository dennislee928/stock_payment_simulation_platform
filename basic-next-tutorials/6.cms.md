# Next.js 應用程式資料管理與整合

本文將說明在 Next.js 應用程式中進行資料管理與整合的相關概念，主要涵蓋 Sanity CMS 整合、API 路由以及使用者驗證，並附上使用 Mermaid 語法繪製的抽象概念圖。

## Sanity CMS 整合

若您的 Next.js 應用程式需要內容管理系統，**Sanity CMS** 是一個強大的選擇，且與 Next.js 有良好的整合 [1-20]。以下是整合 Sanity CMS 的主要步驟和概念：

- **設定 Sanity 專案**：您需要先在 Sanity 平台建立一個專案，並透過 Sanity CLI 初始化您的 Next.js 專案 [7, 8]。這會建立必要的設定檔案，例如 `sanity.config.ts` 和 `sanity/client.ts` [8, 9].
- **定義 Schema**：在 Sanity Studio 中，您需要定義應用程式所需的資料結構 (Schemas)，例如文章、作者、產品等 [21-23]。這些 Schema 定義了資料的欄位和類型。Next.js 專案中 `sanity/schemas` 資料夾下的檔案（例如 `author.ts`, `startup.ts`, `playlist.ts`）就是用於定義這些 Schema [21-23]。
- **資料讀取 (Fetching Data)**：Next.js 應用程式可以使用 Sanity 提供的 **GROQ (GraphQL Query Language)** 來查詢和獲取 Sanity CMS 中的資料 [12-14, 16, 18, 24, 25]。您可以在 Next.js 的 server components 中使用 `@sanity/client` 建立的 `client` 物件來執行 GROQ 查詢 [14]. 為了獲得更好的效能，可以設定 `useCDN` 選項來利用 Sanity 的 CDN 快取 [9, 16].
- **資料即時更新 (Live Updates)**：Next.js 和 Sanity 提供了即時資料更新的功能。透過使用 `next-sanity` 提供的 `defineLive` 和 `sanityFetch` 工具，以及在頁面中加入 `<SanityLive>` 組件，您可以使 Next.js 應用程式在 Sanity CMS 內容變更時自動重新驗證和更新頁面 [26].
- **型別生成 (Type Generation)**：為了提升 TypeScript 的開發體驗，`@sanity/type-gen` 可以根據您的 Sanity Schema 和 GROQ 查詢自動生成 TypeScript 型別，確保資料的一致性和型別安全 [15, 27].
- **資料寫入 (Writing Data)**：您可以使用 Sanity 提供的 **Write Client** 來從 Next.js 應用程式寫入或更新 Sanity CMS 中的資料 [17, 18, 28]. 這需要設定具有寫入權限的 API Token [17].
- **與 Next.js App Router 整合**：Sanity 可以很好地與 Next.js 13 的 App Router 整合，在 server components 中進行資料獲取，並利用 Next.js 的 caching 和 rendering 策略 [16, 29, 30].

## API 路由

Next.js 允許您在 `app/api` 目錄下建立後端 **API 路由 (Route Handlers)** [31]. 這些路由是 Serverless Functions，可以處理 HTTP 請求（例如 GET, POST, PUT, DELETE）並回傳 JSON 或其他格式的資料 [31].

- **建立 API 路由**：在 `app/api` 目錄下建立資料夾和 `route.ts` (或 `.js`) 檔案。例如，`app/api/books/route.ts` 可以處理 `/api/books` 的請求 [31].
- **處理請求**：在 `route.ts` 檔案中，您可以 export 處理不同 HTTP 方法的 async 函式，例如 `GET()`, `POST()`, `PUT()`, `DELETE()` [31].
- **動態路由**：API 路由也支援動態路由。例如，`app/api/books/[id]/route.ts` 可以處理 `/api/books/:id` 的請求，其中 `[id]` 是動態的路徑參數 [31].
- **與前端互動**：前端 React 組件可以使用 `fetch` API 或其他 HTTP 客戶端庫來呼叫這些 API 路由，進行資料的讀取和寫入 [31].

## 驗證

Next.js 應用程式可以使用 **NextAuth.js (next-auth 或 @next-auth/core)** 進行使用者驗證 [10, 18, 32-39]。它支援多種驗證提供者（例如 GitHub, Google）和不同的驗證策略。

- **安裝 NextAuth.js**：使用 `npm` 或 `yarn` 安裝 `@next-auth/core` 和您需要的驗證提供者 [32].
- **設定環境變數**：設定與驗證提供者相關的憑證和密鑰，例如 GitHub Client ID 和 Client Secret，並儲存在 `.env.local` 檔案中 [32, 34].
- **建立 NextAuth.js 設定**：在 `app/api/auth/[...nextauth]/route.ts` 檔案中建立 NextAuth.js 的路由處理器，並配置提供者、回調函數 (callbacks) 和其他選項 [33].
- **處理回調函數 (Callbacks)**：NextAuth.js 允許您定義回調函數（例如 `signIn`, `jwt`, `session`）來處理驗證流程中的不同階段，例如在使用者成功登入後檢查或建立使用者資料 [18, 36].
- **取得使用者 Session**：在前端組件中，可以使用 `@next-auth/react` 提供的 `useSession` hook 或伺服器端的 `getServerSession` 函式來取得目前使用者的驗證狀態和 Session 資料 [37-39].
- **保護路由**：您可以在 Next.js 組件或 middleware 中檢查使用者的 Session 狀態，以保護特定的路由或功能，只允許已驗證的使用者存取 [38].
- **與 Sanity 整合驗證資訊**：在使用者登入成功後，您可以利用 NextAuth.js 的回調函數與 Sanity CMS 互動，例如檢查 Sanity 中是否存在對應的使用者資料，如果不存在則創建新的使用者資料 [18].

## 資料管理與整合抽象概念圖 (Mermaid)

```mermaid
graph TD
    subgraph Next.js Frontend
        A[使用者介面 (React Components)] --> B(API 路由請求 (fetch));
        A --> C(getServerSession / useSession);
        C --> D{使用者已驗證?};
    end

    subgraph Next.js Backend (API Routes)
        B --> E(app/api 路由處理器);
        E --> F(Sanity Client);
        E --> G(NextAuth.js 路由處理器);
        G --> H(驗證提供者 (GitHub, Google, ...));
        G --> I(Sanity Write Client);
    end

    subgraph Sanity CMS
        F -- GROQ 查詢 --> J(Sanity 資料庫);
        I -- 資料寫入 --> J;
    end

    D -- 是 --> A;
    D -- 否 --> L[重新導向至登入頁面];
    H -- 驗證成功/失敗 --> G;
    J -- 資料變更 (Webhook/Live Updates) --> M[Next.js Backend / Frontend];

    style A,C,D,L fill:#f9f,stroke:#333,stroke-width:2px
    style B,E,F,G,H,I,J,M fill:#fff,stroke:#333,stroke-width:1px

    direction LR

圖表說明：
1.
使用者介面 (Next.js Frontend)：使用者與應用程式的 React 組件互動 [A]。
2.
API 路由請求：前端組件可以透過 fetch API 向 Next.js 後端的 API 路由發送請求 [B]。
3.
驗證狀態檢查：前端組件可以使用 getServerSession 或 useSession 檢查使用者的驗證狀態 [C]。
4.
使用者驗證判斷：根據驗證狀態，決定是否允許使用者存取特定功能或路由 [D]。
5.
API 路由處理器 (Next.js Backend)：app/api 目錄下的路由處理器接收前端的請求 [E]。
6.
Sanity Client：API 路由可以使用 Sanity Client 向 Sanity CMS 發送 GROQ 查詢以讀取資料 [F]。
7.
NextAuth.js 路由處理器：app/api/auth/[...nextauth] 路由處理器處理使用者的驗證請求 [G]。
8.
驗證提供者：NextAuth.js 可以與不同的驗證提供者（例如 GitHub, Google）進行互動以驗證使用者身份 [H]。
9.
Sanity Write Client：API 路由可以使用 Sanity Write Client 將資料寫入或更新至 Sanity CMS [I]。
10.
Sanity 資料庫：Sanity CMS 的後端資料庫儲存所有內容 [J]。
11.
資料變更通知：Sanity CMS 的資料變更可以透過 Webhook 或 Live Updates 機制通知 Next.js 後端或前端，實現即時更新 [M]。
12.
重新導向：如果使用者未經驗證嘗試存取受保護的資源，則會被重新導向至登入頁面 [L]。
此圖表抽象地展示了 Next.js 應用程式如何透過 API 路由與 Sanity CMS 進行資料的讀取和寫入，以及如何利用 NextAuth.js 進行使用者驗證，從而實現完整的資料管理與整合流程。

```
