import{a as e}from"./useCart.mjs";import{b as t,c as a,v as r,d as n,f as s,e as o}from"./server.mjs";import{D as c}from"../nitro/nitro.mjs";function useRequestFetch(){var e;return(null==(e=function(e){var a;return e||(e=t()),null==(a=e.ssrContext)?void 0:a.event}())?void 0:e.$fetch)||globalThis.$fetch}function useAsyncData(...e){var s;const o="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(o);let[c,i,l={}]=e;if("string"!=typeof c)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof i)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const u=t(),d=i;l.server??(l.server=!0),l.default??(l.default=()=>a.value),l.getCachedData??(l.getCachedData=()=>u.isHydrating?u.payload.data[c]:u.static.data[c]),l.lazy??(l.lazy=!1),l.immediate??(l.immediate=!0),l.deep??(l.deep=a.deep),l.dedupe??(l.dedupe="cancel");const f=l.getCachedData(c,u),y=null!=f;if(!u._asyncData[c]||!l.immediate){(s=u.payload._errors)[c]??(s[c]=a.errorValue);const e=l.deep?r.ref:r.shallowRef;u._asyncData[c]={data:e(y?f:l.default()),pending:r.ref(!y),error:r.toRef(u.payload._errors,c),status:r.ref("idle"),_default:l.default}}const p={...u._asyncData[c]};delete p._default,p.refresh=p.execute=(e={})=>{if(u._asyncDataPromises[c]){if("defer"===(t=e.dedupe??l.dedupe)||!1===t)return u._asyncDataPromises[c];u._asyncDataPromises[c].cancelled=!0}var t;if(e._initial||u.isHydrating&&!1!==e._initial){const t=e._initial?f:l.getCachedData(c,u);if(null!=t)return Promise.resolve(t)}p.pending.value=!0,p.status.value="pending";const s=new Promise(((e,t)=>{try{e(d(u))}catch(e){t(e)}})).then((async e=>{if(s.cancelled)return u._asyncDataPromises[c];let t=e;l.transform&&(t=await l.transform(e)),l.pick&&(t=function(e,t){const a={};for(const r of t)a[r]=e[r];return a}(t,l.pick)),u.payload.data[c]=t,p.data.value=t,p.error.value=a.errorValue,p.status.value="success"})).catch((e=>{if(s.cancelled)return u._asyncDataPromises[c];p.error.value=n(e),p.data.value=r.unref(l.default()),p.status.value="error"})).finally((()=>{s.cancelled||(p.pending.value=!1,delete u._asyncDataPromises[c])}));return u._asyncDataPromises[c]=s,u._asyncDataPromises[c]},p.clear=()=>function(e,t){t in e.payload.data&&(e.payload.data[t]=void 0);t in e.payload._errors&&(e.payload._errors[t]=a.errorValue);e._asyncData[t]&&(e._asyncData[t].data.value=void 0,e._asyncData[t].error.value=a.errorValue,e._asyncData[t].pending.value=!1,e._asyncData[t].status.value="idle");t in e._asyncDataPromises&&(e._asyncDataPromises[t]&&(e._asyncDataPromises[t].cancelled=!0),e._asyncDataPromises[t]=void 0)}(u,c);if(!1!==l.server&&u.payload.serverRendered&&l.immediate){const e=p.refresh({_initial:!0});r.getCurrentInstance()?r.onServerPrefetch((()=>e)):u.hook("app:created",(async()=>{await e}))}const m=Promise.resolve(u._asyncDataPromises[c]).then((()=>p));return Object.assign(m,p),m}function useFetch(e,t,a){const[n={},o]="string"==typeof t?[{},t]:[t,a],i=r.computed((()=>r.toValue(e))),l=n.key||c([o,"string"==typeof i.value?i.value:"",...generateOptionSegments(n)]);if(!l||"string"!=typeof l)throw new TypeError("[nuxt] [useFetch] key must be a string: "+l);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const u=l===o?"$f"+l:l;if(!n.baseURL&&"string"==typeof i.value&&"/"===i.value[0]&&"/"===i.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:d,lazy:f,default:y,transform:p,pick:m,watch:v,immediate:h,getCachedData:g,deep:D,dedupe:w,..._}=n,b=r.reactive({...s,..._,cache:"boolean"==typeof n.cache?void 0:n.cache});let P;return useAsyncData(u,(()=>{var e;null==(e=null==P?void 0:P.abort)||e.call(P,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),P="undefined"!=typeof AbortController?new AbortController:{};const t=r.toValue(n.timeout);let a;t&&(a=setTimeout((()=>P.abort(new DOMException("Request aborted due to timeout.","AbortError"))),t),P.signal.onabort=()=>clearTimeout(a));let s=n.$fetch||globalThis.$fetch;if(!n.$fetch){"string"==typeof i.value&&"/"===i.value[0]&&(!r.toValue(n.baseURL)||"/"===r.toValue(n.baseURL)[0])&&(s=useRequestFetch())}return s(i.value,{signal:P.signal,...b}).finally((()=>{clearTimeout(a)}))}),{server:d,lazy:f,default:y,transform:p,pick:m,immediate:h,getCachedData:g,deep:D,dedupe:w,watch:!1===v?[]:[b,i,...v||[]]})}function generateOptionSegments(e){var t;const a=[(null==(t=r.toValue(e.method))?void 0:t.toUpperCase())||"GET",r.toValue(e.baseURL)];for(const t of[e.params||e.query]){const e=r.toValue(t);if(!e)continue;const n={};for(const[t,a]of Object.entries(e))n[r.toValue(t)]=r.toValue(a);a.push(n)}return a}function useStocks(){o().public.twseApiBase;const t=r.ref(!1),a=r.ref(null),n=e();async function getStockPrice(e){try{const{data:t}=await useFetch(`/api/stocks/${e}`,"$7Ngwt8kFVH");return t.value&&t.value.price&&n.cacheStock({...n.getStockBySymbol(e),symbol:e,price:t.value.price,change:t.value.change,changePercent:t.value.changePercent,date:t.value.date}),t.value}catch(t){throw console.error(`取得股票 ${e} 價格時發生錯誤:`,t),new Error(`無法取得股票 ${e} 的價格資訊`)}}return{loading:t,error:a,searchStock:async function(e){if(e&&!(e.length<2)){t.value=!0,a.value=null;try{const{data:t}=await useFetch("/api/twse/companies","$6l2edTTtm6");if(!t.value||!Array.isArray(t.value))throw new Error("無法取得公司資料");const a=t.value.filter((t=>{const a=t.Name||"",r=t.Code||"";return a.includes(e)||r.includes(e)})).map((e=>({symbol:e.Code,name:e.Name,industry:e.Industry,price:0})));return a.length>0&&(n.setSearchResults(a),await Promise.all(a.slice(0,5).map((async e=>{await getStockPrice(e.symbol)})))),a}catch(e){return console.error("搜尋股票時發生錯誤:",e),a.value="搜尋股票時發生錯誤，請稍後再試",[]}finally{t.value=!1}}},getStockPrice:getStockPrice,recentStocks:r.computed((()=>n.recentStocks)),favoriteStocks:r.computed((()=>n.favoriteStocks)),toggleFavorite:n.toggleFavorite}}export{useStocks as u};
//# sourceMappingURL=useStocks.mjs.map
