# Next.js App Router 資料獲取 (Data Fetching) 概覽

資料獲取是現代 Web 應用程式開發的核心部分，Next.js App Router 引入了多種簡化且強大的資料獲取方法。以下將概述 App Router 中主要的資料獲取概念與實踐，並附上 Mermaid 圖表以助理解。

## 主要資料獲取方法

### 1. `fetch` API

- 在 App Router 中，**伺服器組件 (Server Components) 內可以直接使用原生的 `fetch` API 獲取資料** [1-5]。這使得在伺服器端進行資料請求變得非常方便。
- **App Router 中 `fetch` 的預設行為已變更為自動快取 (caching)** [6, 7]。對於相同的請求 (相同的 URL 和 `cache` 選項)，Next.js 會自動在伺服器端的資料快取中儲存結果，並在後續的請求中重複使用，藉此提升效能 [5, 7]。
- 可以透過 `fetch` 的 `cache` 選項來控制快取行為，例如：
  - `'force-cache'` (預設)：強制使用快取資料，如果快取中沒有則重新獲取並儲存。
  - `'no-store'`: 不使用或儲存任何快取資料，每次都重新獲取。
  - `'revalidate <seconds>'`: 在指定的秒數後重新驗證快取。
- `fetch` 請求會在相同的 `generateMetadata`、`generateStaticParams`、Layouts、Pages 和伺服器組件之間自動記憶化 (memoized) [5]。

### 2. `generateStaticParams` (靜態站點生成 - SSG)

- `generateStaticParams` 是一個**伺服器端異步函數，用於預先生成具有動態路由的靜態頁面** [8-10]。
- 當你的頁面路徑包含動態片段 (例如 `app/products/[id]/page.tsx`) 時，`generateStaticParams` 會定義在建置時需要生成哪些具體的 `id` 值。
- Next.js 會在建置時針對 `generateStaticParams` 返回的每個參數組合執行資料獲取和頁面渲染，產生靜態 HTML 檔案 [9].
- 這對於內容在建置後不常變動的頁面非常有用，可以提供極佳的效能和 SEO。

### 3. `unstable_cache` (伺服器端資料快取)

- 雖然在提供的資料來源中沒有詳細說明，但 `unstable_cache` 是 Next.js 提供的一個更底層的 API，**用於在伺服器端快取資料**。
- 它提供了比 `fetch` 預設快取更細緻的控制，例如可以設定快取的失效時間和標籤。

### 4. 伺服器組件中的資料獲取

- **App Router 強調在伺服器組件中進行資料獲取** [1-5, 11]。
- 伺服器組件在伺服器端執行，因此可以直接安全地存取後端資源 (例如資料庫、API 金鑰等)，而無需將敏感資訊暴露給瀏覽器。
- 在伺服器組件中使用 `async/await` 語法搭配 `fetch` 可以非常直觀地進行資料獲取。
- 值得注意的是，**靜態和動態中繼資料 (`generateMetadata`) 只能在伺服器組件中使用** [5, 11]。

### 5. 使用 Sanity CMS 進行資料管理和獲取

- Sanity 是一個內容管理系統 (CMS)，可以作為 Next.js 應用程式的後端資料來源 [3, 12-19]。
- Next.js 可以透過 Sanity 提供的 API 和 SDK (例如 `@sanity/client`) 來**查詢和獲取 Sanity 中管理的內容** [19-22]。
- **GROQ (Graph-Relational Object Queries)** 是 Sanity 的查詢語言，用於精確地指定需要獲取的資料 [20-22]。
- 可以使用 `@sanity/client` 建立 Sanity 的讀取和寫入客戶端，並在伺服器組件中進行資料操作 [19, 23].
- **`next-sanity/live` 提供了與 Sanity Live Content API 的整合，可以實現近乎實時的資料更新** [24-27]。當 Sanity 中的內容發生變化時，使用 `sanityFetch` 和 `<SanityLive>` 組件的 Next.js 應用程式可以自動接收並顯示最新的資料，無需手動重新載入 [26, 27]。

## 資料獲取概念圖 (Mermaid)

```mermaid
graph LR
    subgraph Client Interaction
        A[Client Component] -- User Request --> B(Next.js Server);
    end

    subgraph Server-Side Data Fetching (Server Components)
        B --> C{Server Component (Page/Layout)};
        C -- fetch('...') --> D{Next.js Cache?};
        D -- Yes --> E[Cached Data];
        D -- No --> F[Data Source (API/DB/CMS)];
        F -- Data --> G[Server Response];
        G --> H(Next.js Data Cache);
        H -- Cached Data --> E;
        E --> C;
        C -- Rendered HTML/JSON --> B;
    end

    subgraph Static Site Generation (SSG)
        I[Build Process] --> J{generateStaticParams?};
        J -- Yes --> K[Fetch Data (Build Time)];
        K --> L[Statically Generated Pages (.html, .json)];
        L -- Served Directly --> A;
    end

    subgraph Incremental Static Regeneration (ISR)
        B --> M{Check Cache (Stale?)};
        M -- Yes (Valid) --> N[Serve Cached Page];
        M -- No (or Revalidation Interval) --> O[Fetch Data (Background Revalidation)];
        O -- Data --> P(Update Next.js Cache);
        P --> N;
        N --> A;
    end

    subgraph Real-time Data (Sanity Live)
        A -- WebSocket Connection --> Q(Sanity Live API);
        Q -- Data Updates --> R[Next.js Server (using sanityFetch + SanityLive)];
        R -- Re-render Server Component --> B;
        subgraph Sanity CMS
            F -- GROQ Query --> Sanity API;
            Sanity API -- Data --> G;
            Q -- Content Updates --> Sanity API;
        end
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style I fill:#ccf,stroke:#333,stroke-width:2px
    style B,C,D,E,F,G,H,M,N,O,P,Q,R fill:#fff,stroke:#333,stroke-width:1px

圖表說明:
•
Client Interaction: 使用者與前端 Client Component 互動，發出請求到 Next.js Server。
•
Server-Side Data Fetching (Server Components):
◦
Server Component 接收到請求後，可以使用 fetch 獲取資料。
◦
Next.js 會檢查資料是否已在 Cache 中。
◦
如果有，則直接使用快取資料。
◦
如果沒有，則從 Data Source (API、資料庫、CMS) 獲取資料，並將結果儲存到 Next.js Data Cache 中。
◦
Server Component 使用獲取的資料渲染 HTML 或 JSON，並回傳給 Client。
•
Static Site Generation (SSG):
◦
在建置過程中，如果頁面使用了 generateStaticParams，Next.js 會預先獲取資料並生成靜態頁面。
◦
這些靜態頁面可以直接由 CDN 提供服務，具有極高的效能。
•
Incremental Static Regeneration (ISR):
◦
Server 接收到請求後，會檢查 Cache 中的頁面是否仍然有效。
◦
如果有效，則直接提供快取頁面。
◦
如果過期 (或達到重新驗證間隔)，Next.js 會在背景重新獲取資料並更新 Cache，下次請求時將提供最新的頁面。
•
Real-time Data (Sanity Live):
◦
Client 與 Sanity Live API 建立 WebSocket 連線。
◦
當 Sanity CMS 中的內容更新時，Live API 會推送更新到 Next.js Server。
◦
使用 sanityFetch 和 <SanityLive> 的 Server Component 會接收到這些更新並重新渲染，最終將最新的資料顯示在 Client 端。
總結
Next.js App Router 提供了多樣化的資料獲取策略，開發者可以根據應用程式的需求選擇最適合的方法。伺服器組件和 fetch API 的預設快取機制簡化了伺服器端資料獲取，並提升了應用程式的效能。generateStaticParams 適用於靜態內容的預先生成，而 ISR 則在靜態和動態之間取得平衡。對於需要實時更新的場景，與 Sanity Live API 的整合提供了強大的解決方案。 理解這些概念和方法對於開發高效能且使用者體驗良好的 Next.js 應用程式至關重要。
```

# Next.js App Router 渲染策略概覽

Next.js App Router 提供了多種渲染策略，讓開發者可以根據應用程式的需求和內容特性選擇最適合的方式來呈現網頁。以下將詳細介紹這些渲染策略，並使用 Mermaid 圖表進行視覺化呈現。

## 主要渲染策略

### 1. 靜態站點生成 (Static Site Generation, SSG)

- **定義**：靜態站點生成是一種在**建置時預先生成 HTML 頁面**的技術 [1-3]。這表示在使用者請求頁面之前，HTML 內容就已經存在 [3]。
- **運作方式**：Next.js 會在 `npm run build` 時執行資料獲取，並根據頁面組件和資料預先生成 HTML 檔案 [3, 4]。這些 HTML 檔案可以直接透過 CDN 快速地提供給使用者 [3]。
- **優點**：極快的載入速度、優秀的 SEO (搜尋引擎優化) [3, 5]，降低伺服器負載 [3]。
- **適用場景**：部落格、文件網站、行銷頁面等**內容不常變動**的網站 [3]。當知道動態路由的所有可能參數時，可以使用 `generateStaticParams` 這個伺服器端非同步函數來預先生成靜態頁面 [1, 6, 7]。即使是 SSG 頁面，也可以使用**增量靜態再生 (ISR)** 策略進行後續的內容更新 [1]。
- **相關 API/配置**：`generateStaticParams` [1] (用於預先生成具有動態路由的靜態頁面)。

### 2. 伺服器端渲染 (Server-Side Rendering, SSR)

- **定義**：伺服器端渲染是一種**在每次使用者請求頁面時，於伺服器端動態生成 HTML** 的技術 [2, 3, 8]。
- **運作方式**：當使用者發送請求時，Next.js 伺服器會執行頁面組件中的程式碼，獲取資料並渲染成 HTML，然後將完整的 HTML 回傳給瀏覽器 [8]。瀏覽器收到 HTML 後可以直接顯示內容，之後再進行 JavaScript 的 hydration (水合作用)，使頁面具有互動性 [2]。可以透過將 `revalidate` 設為 `0` 來強制 Next.js 在每次請求時都渲染頁面 [8]。
- **優點**：改善首頁載入時間 (TTFB)，有助於 SEO (尤其對於動態內容) [5]。
- **缺點**：相較於 SSG，伺服器負載較高，回應速度可能稍慢 [3]。
- **適用場景**：需要**頻繁更新的動態內容**、使用者個人化內容、電商網站的商品頁面等 [8]。對於動態路由，如果在建置時不知道所有可能的參數，則預設會使用 SSR [7]。然而，透過 `generateStaticParams`，可以將 SSR 頁面轉換為 SSG 頁面 [1, 6]。
- **相關 API/配置**：將 `revalidate` 設定為 `0` [8]。

### 3. 客戶端渲染 (Client-Side Rendering, CSR)

- **定義**：客戶端渲染是一種**瀏覽器接收到基本的 HTML 骨架後，再透過 JavaScript 在瀏覽器端動態渲染內容**的技術。
- **運作方式**：伺服器只回傳一個包含少量 HTML 和指向 JavaScript 檔案的連結。瀏覽器下載 JavaScript 後執行，並向 API 發送請求獲取資料，然後使用這些資料動態地更新 DOM (Document Object Model) [5]。
- **優點**：首次載入後頁面切換速度快。
- **缺點**：首頁載入時間可能較長，不利於 SEO (因為初始 HTML 內容較少)。
- **適用場景**：高度互動性的 Web 應用程式、儀表板等。
- **Next.js 的關聯**：雖然 Next.js 強調伺服器端渲染和靜態生成，但在 Next.js 應用程式中仍然可以使用客戶端渲染，特別是在需要特定瀏覽器互動的功能或動態內容的特定區塊。在預設情況下，Next.js App Router 中的元件是**伺服器組件 (Server Components)** [9]，它們在伺服器端執行。若要使元件在客戶端執行並具有互動性，需要明確地將其標記為**客戶端組件 (Client Components)**，方法是在檔案頂部加入 `'use client'` 指令 [2, 10]。伺服器組件會在伺服器端預先渲染以創建靜態外殼，然後在客戶端進行 hydration [2]。

### 4. 增量靜態再生 (Incremental Static Regeneration, ISR)

- **定義**：增量靜態再生是 SSG 的一種擴展，它**允許你在不重新部署的情況下更新已生成的靜態內容** [2, 3]。
- **運作方式**：Next.js 在建置時生成靜態頁面，當使用者請求這些頁面時，會先提供已快取的靜態內容。同時，Next.js 會在後台重新驗證資料，並在指定的間隔時間後 (或根據需求) 更新快取中的頁面 [3]。下次使用者再次請求該頁面時，就會看到最新的內容 [11]。
- **優點**：結合了 SSG 的速度和 SSR 的動態更新能力，降低伺服器負載，並能及時更新內容。
- **適用場景**：內容不頻繁但偶爾需要更新的網站，例如具有新聞頭條或促銷資訊的部落格或電商網站 [3, 12]。
- **相關 API/配置**：
  - **基於時間的重新驗證**：在 `fetch` 選項中設定 `next: { revalidate: <秒數> }` [2, 3]，或在 Layout 或 Page 層級匯出 `export const revalidate = <秒數>` [11]。設定為 60 秒表示 Next.js 會在背景每 60 秒重新驗證資料 [13]。
  - **按需重新驗證**：可以使用 `revalidatePath` 和 `revalidateTag` 進行按需的內容重新驗證 [3]。

### 5. 部分預先渲染 (Partial Prerendering, PPR)

- **定義**：部分預先渲染是一種**實驗性的渲染模型**，它結合了靜態和動態渲染，允許你在同一個頁面中同時擁有靜態和動態部分 [3, 6, 8, 14]。
- **運作方式**：在建置時，Next.js 會預先渲染頁面的靜態部分，並為動態內容留下佔位符。當使用者請求頁面時，靜態外殼會立即被提供，然後動態內容會以串流的方式逐步載入 [8, 12, 14-16]。可以使用 React 的 `<Suspense>` 組件來包裹動態組件，並提供 fallback 內容 [8, 16]。
- **優點**：提升初始載入速度 (因為靜態部分先載入)，同時保持動態內容的即時性 [8, 14]。可以更精細地控制頁面的哪些部分需要動態更新，哪些部分可以保持靜態 [12, 14, 17]。
- **缺點**：目前仍為實驗性功能 [6, 18]。
- **適用場景**：需要快速載入靜態內容，但同時頁面某些部分需要動態更新的應用程式，例如電商網站的商品詳情頁面 (商品資訊靜態，但庫存或推薦商品動態) [12, 14, 17, 19]。使用者個人資料頁面 (使用者資訊靜態，但最近的活動動態) [12]。
- **相關 API/配置**：

  - 在 `next.config.ts` 中啟用：

    ```javascript
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      experimental: {
        ppr: "incremental",
      },
    };

    module.exports = nextConfig;
    ```

  - 在需要使用 PPR 的頁面中標記：
    ```typescript
    export const experimentalPPR = true;
    ```
  - 使用 React 的 `<Suspense>` 組件包裹動態組件 [8, 16]。

## 渲染策略概念圖 (Mermaid)

```mermaid
graph TD
    subgraph Client Request
        A[Browser] -- Request --> B(Next.js Server);
    end

    subgraph Static Site Generation (SSG)
        B -- Build Time --> C{generateStaticParams?};
        C -- Yes --> D[Fetch Data];
        D --> E[Pre-rendered HTML];
        E -- Served by CDN --> A;
        E -- Revalidation (ISR) --> F{Cache Stale?};
        F -- Yes --> D;
        F -- No --> E;
    end

    subgraph Server-Side Rendering (SSR)
        B -- Request --> G[Fetch Data];
        G --> H[Render HTML on Server];
        H -- Send HTML --> A;
    end

    subgraph Client-Side Rendering (CSR)
        B -- Initial HTML (minimal) --> I[Browser];
        I -- Download JavaScript --> J[Execute JavaScript];
        J -- Fetch Data --> K[Render in Browser];
        K --> A;
    end

    subgraph Incremental Static Regeneration (ISR)
        L[First Request] --> M[Serve Cached Static Page];
        M -- Background Revalidation (Time/On-Demand) --> D;
        L -- Subsequent Request (after revalidation) --> E;
    end

    subgraph Partial Prerendering (PPR)
        B -- Build Time --> N[Pre-render Static Shell];
        N --> O[Serve Static Shell];
        O -- Request Dynamic Content (within Suspense) --> G;
        G --> P[Stream Dynamic Content to Client];
        P --> A;
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B,C,D,E,F,G,H,I,J,K,L,M,N,O,P fill:#fff,stroke:#333,stroke-width:1px

圖表說明:
•
Client Request: 使用者透過瀏覽器發送請求到 Next.js 伺服器。
•
Static Site Generation (SSG):
◦
在建置時，如果使用了 generateStaticParams，則會預先獲取資料並生成靜態 HTML。
◦
靜態 HTML 可以直接由 CDN 提供服務給使用者。
◦
透過 ISR，可以定期或按需重新驗證資料並更新靜態內容。
•
Server-Side Rendering (SSR):
◦
每次收到使用者請求時，伺服器會先獲取資料，然後將資料渲染到 HTML 中，最後將完整的 HTML 回傳給瀏覽器。
•
Client-Side Rendering (CSR):
◦
伺服器回傳最基本的 HTML 結構和 JavaScript 檔案。
◦
瀏覽器下載並執行 JavaScript 後，再向伺服器請求資料並在客戶端渲染頁面。
•
Incremental Static Regeneration (ISR):
◦
首次請求時，提供已快取的靜態頁面。
◦
在背景根據設定的時間間隔或按需觸發資料重新驗證。
◦
重新驗證後，下次請求將提供最新的靜態頁面。
•
Partial Prerendering (PPR):
◦
在建置時預先渲染頁面的靜態外殼。
◦
伺服器先將靜態外殼傳送給瀏覽器。
◦
瀏覽器再非同步地請求並串流接收頁面中的動態內容 (通常在 <Suspense> 包裹下)。
總結
Next.js App Router 提供了豐富的渲染策略，開發者可以根據頁面的特性選擇最適合的方案。SSG 適用於靜態內容，提供最佳效能和 SEO；SSR 適用於動態內容，確保內容的即時性；CSR 用於需要高度互動性的部分；ISR 則在靜態效能和動態更新之間取得平衡；而實驗性的 PPR 則進一步提供了更細緻的控制，允許在同一頁面中混合使用靜態和動態渲染。 了解這些渲染策略的運作方式和適用場景，對於建構高效能且使用者體驗良好的 Next.js 應用程式至關重要。
```

增量靜態再生 (ISR) 與部分預先渲染 (PPR)

本文將深入探討 Next.js 中兩種進階的渲染策略：**增量靜態再生 (Incremental Static Regeneration, ISR)** 和**部分預先渲染 (Partial Prerendering, PPR)**。我們將了解它們的優勢、使用方法，並透過 Mermaid 語法繪製抽象概念圖。

## 增量靜態再生 (ISR)

**增量靜態再生 (ISR)** 是一種 Next.js 功能，允許您在**建置時靜態生成頁面**，然後在**背景中以指定的時間間隔重新生成這些頁面** [1, 2]。這代表著您的使用者首次請求頁面時，將會立即獲得**極快的靜態內容**，而在後續的請求中，Next.js 會在背景檢查頁面是否需要更新，並在下次請求時提供最新的版本 [3]。

### 優勢

- **效能提升**：由於頁面在建置時即已生成，因此首次載入速度非常快，如同傳統的靜態網站 [1].
- **內容更新**：相較於純靜態生成，ISR 允許您在不必重新建置整個網站的情況下更新內容 [1].
- **彈性**：您可以根據內容的更新頻率設定不同的重新驗證間隔 [1].
- **降低伺服器負載**：由於大部分的請求都由靜態內容處理，伺服器僅需在重新驗證間隔到期後才進行頁面重新生成，有助於降低伺服器負載 [3].
- **與 CDN 良好整合**：靜態生成的頁面可以輕易地部署至 CDN，進一步提升效能 [3].

### 使用方法

您可以在 `getStaticProps` 函式中設定 `revalidate` 屬性來啟用 ISR [1]. `revalidate` 的值為秒數，表示 Next.js 在這個時間間隔後會嘗試重新生成頁面 [1].

```javascript
export async function getStaticProps() {
  const posts = await fetch('...');
  return {
    props: {
      posts,
    },
    revalidate: 60, // 每 60 秒重新生成頁面
  };
}

在伺服器組件 (Server Components) 中，您可以使用 next-sanity 提供的 sanityFetch 並搭配 Sanity Client 的 useCDN: true (預設值) 來實現類似的 ISR 行為。Sanity 會在 60 秒後重新驗證內容
。

import { sanityFetch } from './sanity/lib/live';
import { startupQuery } from './sanity/lib/queries';

export default async function HomePage() {
  const posts = await sanityFetch({ query: startupQuery });
  // ... 渲染頁面
}

在 Sanity 的設定中，將 useCDN 設定為 true 會使 Sanity 在 60 秒後快取過期並重新獲取較新的資料
。
抽象概念圖 (Mermaid)

graph LR
    A[使用者請求頁面] --> B{頁面是否在快取中?};
    B -- 是 --> C[提供快取中的靜態內容];
    B -- 否 --> D[建置時靜態生成];
    D --> C;
    C --> E[設定重新驗證間隔];
    E -- 時間間隔到期 --> F[背景重新生成頁面];
    F --> G[更新快取];
    G --> H[下次請求提供新內容];

部分預先渲染 (PPR)
部分預先渲染 (Partial Prerendering, PPR) 是一種 實驗性 的 Next.js 14 功能
。PPR 的核心概念是將頁面的一部分靜態預先渲染，而將其他部分保留為動態渲染。這允許開發者針對頁面中的不同部分採用最適合的渲染策略
।
理解 PPR
傳統的渲染策略通常是整個頁面採用單一的渲染方式（例如，完全靜態生成或完全伺服器端渲染）。PPR 則提供了更細緻的控制，讓您可以混合使用靜態和動態渲染，以優化效能和使用者體驗
।
例如，一個產品詳情頁面可能包含大部分靜態的產品資訊（名稱、描述、圖片），但同時也包含動態的元素（例如，商品庫存、使用者評價、瀏覽次數）
। 使用 PPR，您可以靜態預先渲染產品資訊以實現快速載入，而將庫存和評價等動態部分保留為客戶端或伺服器端動態渲染
।
潛在優勢
•
更快的初始載入：由於頁面的主要部分是靜態預先渲染的，因此初始載入速度可以顯著提升
।
•
動態內容的靈活性：PPR 允許在靜態頁面中嵌入動態功能，而無需完全放棄靜態渲染的優勢
।
•
細緻的效能優化：開發者可以精確地控制頁面哪些部分是靜態的，哪些是動態的，從而實現更精細的效能優化
।
•
改善使用者體驗：使用者可以更快地看到頁面的主要內容，而動態部分則可以在後續載入
।
使用方法
要啟用 PPR，您需要在 next.config.js 檔案中的 experimental 屬性中將 ppr 設定為 incremental
।

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: true, // 或 'incremental'
  },
};

module.exports = nextConfig;

然後，在您的頁面或佈局檔案中，您需要匯出 experimentalPPR 標誌並設為 true
।

export const experimentalPPR = true;

export default function StartupDetailPage({ params }: { params: { id: string } }) {
  // ... 靜態內容
  return (
    <div>
      {/* 靜態內容 */}
      <Suspense fallback={<Skeleton />}>
        <View id={params.id} /> {/* 動態的瀏覽次數 */}
      </Suspense>
      {/* 更多靜態內容 */}
    </div>
  );
}

對於需要動態渲染的部分，您可以使用 React 的 <Suspense> 組件
。fallback prop 允許您在動態內容載入時顯示一個佔位符（例如，骨架屏）। 您的動態組件（例如上面的 <View>）將在伺服器端或客戶端按需渲染
।
抽象概念圖 (Mermaid)

graph LR
    A[使用者請求頁面] --> B{PPR 是否啟用?};
    B -- 是 --> C[靜態預先渲染頁面主要部分];
    C --> D[瀏覽器接收部分渲染的 HTML];
    D --> E{是否有 <Suspense> 組件?};
    E -- 是 --> F[伺服器/客戶端按需渲染 <Suspense> 中的動態內容];
    F --> G[更新 DOM];
    E -- 否 --> H[完整靜態頁面];
    B -- 否 --> I[傳統渲染策略 (SSG/SSR/CSR)];

總結來說，增量靜態再生 (ISR) 提供了一種在效能和內容更新之間取得平衡的有效方法，特別適合內容不頻繁更新但又需要保持一定新鮮度的網站
। 而 部分預先渲染 (PPR) 作為一項實驗性功能，則展示了未來 Next.js 在更精細地控制渲染策略方面的潛力，尤其是在需要混合靜態和動態內容的複雜應用程式中। 了解和善用這些進階渲染策略，可以幫助您建構出效能更佳、使用者體驗更優的 Next.js 應用程式。
```
